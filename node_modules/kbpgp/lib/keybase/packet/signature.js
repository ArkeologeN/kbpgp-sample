// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var Base, K, Lifespan, Packet, SelfSign, Subkey, SubkeyReverse, bufeq_secure, iced, sign, unix_time, verify, __iced_k, __iced_k_noop, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  Base = require('./base').Base;

  K = require('../../const').kb;

  _ref = require('../sign'), sign = _ref.sign, verify = _ref.verify;

  Packet = require('./base').Packet;

  _ref1 = require('../../util'), bufeq_secure = _ref1.bufeq_secure, unix_time = _ref1.unix_time;

  Lifespan = require('../../keywrapper').Lifespan;

  Base = (function(_super) {
    __extends(Base, _super);

    function Base(_arg) {
      this.type = _arg.type, this.key = _arg.key, this.sig = _arg.sig, this.body = _arg.body;
    }

    Base.prototype.sign = function(_arg, cb) {
      var asp, body, err, include_body, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, include_body = _arg.include_body;
      body = this._v_body();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced",
            funcname: "Base.sign"
          });
          sign({
            key: _this.key,
            type: _this.type,
            body: body,
            include_body: include_body
          }, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                err = arguments[0];
                return __slot_1.sig = arguments[1];
              };
            })(_this),
            lineno: 17
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, _this.sig);
        };
      })(this));
    };

    Base.prototype.frame_packet = function() {
      return Base.__super__.frame_packet.call(this, K.packet_tags.signature, this.sig);
    };

    Base.prototype.signing_ekid = function() {
      return this.body.ekid;
    };

    Base.prototype.verify = function(cb) {
      var d, err, now, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = null;
      now = unix_time();
      if (this.body == null) {
        this.body = this.sig.body;
      }
      (function(_this) {
        return (function(__iced_k) {
          if ((d = now - (_this.body.generated + _this.body.expire_in)) > 0) {
            return __iced_k(err = new Error("signature expired " + d + "s ago"));
          } else {
            (function(__iced_k) {
              if (!bufeq_secure(_this.signing_ekid(), _this.key.ekid())) {
                return __iced_k(err = new Error("trying to verify with the wrong key"));
              } else {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced",
                    funcname: "Base.verify"
                  });
                  verify({
                    type: _this.type,
                    key: _this.key,
                    sig: _this.sig,
                    body: _this.body
                  }, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 40
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              }
            })(__iced_k);
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    Base.prototype.get_lifespan = function() {
      return new Lifespan(this.body);
    };

    return Base;

  })(Packet);

  SelfSign = (function(_super) {
    __extends(SelfSign, _super);

    function SelfSign(_arg) {
      var body, key, sig;
      this.key_wrapper = _arg.key_wrapper, this.userid = _arg.userid, sig = _arg.sig, body = _arg.body;
      key = this.key_wrapper.key;
      SelfSign.__super__.constructor.call(this, {
        type: K.sig_types.self_sign,
        key: key,
        sig: sig,
        body: body
      });
    }

    SelfSign.prototype._v_body = function() {
      return {
        ekid: this.key_wrapper.key.ekid(),
        generated: this.key_wrapper.lifespan.generated,
        expire_in: this.key_wrapper.lifespan.expire_in,
        userid: this.userid
      };
    };

    return SelfSign;

  })(Base);

  Subkey = (function(_super) {
    __extends(Subkey, _super);

    function Subkey(_arg) {
      var body, sig;
      this.subkey = _arg.subkey, sig = _arg.sig, body = _arg.body;
      Subkey.__super__.constructor.call(this, {
        type: K.sig_types.subkey,
        key: this.subkey.primary.key,
        sig: sig,
        body: body
      });
    }

    Subkey.prototype.signing_ekid = function() {
      return this.body.primary_ekid;
    };

    Subkey.prototype._v_body = function() {
      return {
        primary_ekid: this.subkey.primary.ekid(),
        subkey_ekid: this.subkey.ekid(),
        generated: this.subkey.lifespan.generated,
        expire_in: this.subkey.lifespan.expire_in
      };
    };

    return Subkey;

  })(Base);

  SubkeyReverse = (function(_super) {
    __extends(SubkeyReverse, _super);

    function SubkeyReverse(_arg) {
      var body, sig;
      this.subkey = _arg.subkey, sig = _arg.sig, body = _arg.body;
      SubkeyReverse.__super__.constructor.call(this, {
        type: K.sig_types.subkey_reverse,
        key: this.subkey.key,
        sig: sig,
        body: body
      });
    }

    SubkeyReverse.prototype.signing_ekid = function() {
      return this.body.subkey_ekid;
    };

    SubkeyReverse.prototype._v_body = function() {
      return {
        primary_ekid: this.subkey.primary.ekid(),
        subkey_ekid: this.subkey.ekid(),
        generated: this.subkey.lifespan.generated,
        expire_in: this.subkey.lifespan.expire_in
      };
    };

    return SubkeyReverse;

  })(Base);

  exports.SelfSign = SelfSign;

  exports.Subkey = Subkey;

  exports.SubkeyReverse = SubkeyReverse;

}).call(this);
