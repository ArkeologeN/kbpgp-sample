// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var Decryptor, K, P3SKB, Packet, SHA512, box, bufeq_secure, bufferify, iced, make_esc, native_rng, pack, rsa, sign, triplesec, verify, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  K = require('../../const').kb;

  triplesec = require('triplesec');

  SHA512 = require('../../hash').SHA512;

  Decryptor = triplesec.Decryptor;

  native_rng = triplesec.prng.native_rng;

  Packet = require('./base').Packet;

  _ref = require('../encode'), pack = _ref.pack, box = _ref.box;

  make_esc = require('iced-error').make_esc;

  rsa = require('../../rsa');

  _ref1 = require('../sign'), sign = _ref1.sign, verify = _ref1.verify;

  _ref2 = require('../../util'), bufeq_secure = _ref2.bufeq_secure, bufferify = _ref2.bufferify;

  P3SKB = (function(_super) {
    __extends(P3SKB, _super);

    function P3SKB(_arg) {
      var priv, priv_clear;
      this.pub = _arg.pub, priv_clear = _arg.priv_clear, priv = _arg.priv;
      P3SKB.__super__.constructor.call(this);
      this.priv = priv != null ? priv : priv_clear != null ? {
        data: priv_clear,
        encryption: K.key_encryption.none
      } : void 0;
    }

    P3SKB.prototype.frame_packet = function() {
      return P3SKB.__super__.frame_packet.call(this, K.packet_tags.p3skb, {
        pub: this.pub,
        priv: this.priv
      });
    };

    P3SKB.prototype.lock = function(_arg, cb) {
      var asp, ct, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, tsenc = _arg.tsenc;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/keybase/packet/p3skb.iced",
            funcname: "P3SKB.lock"
          });
          tsenc.run({
            data: _this.priv.data,
            progress_hook: asp != null ? asp.progress_hook() : void 0
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return ct = arguments[1];
              };
            })(),
            lineno: 26
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            _this.priv.data = ct;
            _this.priv.encryption = K.key_encryption.triplesec_v3;
          }
          return cb(err);
        };
      })(this));
    };

    P3SKB.prototype.unlock = function(_arg, cb) {
      var asp, dec, err, progress_hook, raw, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, tsenc = _arg.tsenc;
      (function(_this) {
        return (function(__iced_k) {
          switch (_this.priv.encryption) {
            case K.key_encryption.triplesec_v3:
            case K.key_encryption.triplesec_v2:
            case K.key_encryption.triplesec_v1:
              dec = new Decryptor({
                enc: tsenc
              });
              progress_hook = asp != null ? asp.progress_hook() : void 0;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/kbpgp/src/keybase/packet/p3skb.iced",
                  funcname: "P3SKB.unlock"
                });
                dec.run({
                  data: _this.priv.data,
                  progress_hook: progress_hook
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      return raw = arguments[1];
                    };
                  })(),
                  lineno: 37
                }));
                __iced_deferrals._fulfill();
              })(function() {
                dec.scrub();
                return __iced_k(typeof err === "undefined" || err === null ? (_this.priv.data = raw, _this.priv.encryption = K.key_encryption.none) : void 0);
              });
              break;
            case K.key_encryption.none:
              return __iced_k();
            default:
              return __iced_k(err = new Error("Unknown key encryption type: " + k.encryption));
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    P3SKB.alloc = function(_arg) {
      var body, tag;
      tag = _arg.tag, body = _arg.body;
      if (tag === K.packet_tags.p3skb) {
        return new P3SKB(body);
      } else {
        throw new Error("wrong tag found: " + tag);
      }
    };

    P3SKB.alloc_nothrow = function(obj) {
      return katch(function() {
        return P3SKB.alloc(obj);
      });
    };

    P3SKB.prototype.has_private = function() {
      return this.priv != null;
    };

    P3SKB.prototype.is_locked = function() {
      return this.priv.encryption !== K.key_encryption.none;
    };

    return P3SKB;

  })(Packet);

  exports.P3SKB = P3SKB;

}).call(this);
