// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var K, SHA512, alloc, iced, json_encode, pack, sign, verify, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('../hash'), SHA512 = _ref.SHA512, alloc = _ref.alloc;

  K = require('../const').kb;

  pack = require('./encode').pack;

  json_encode = function(_arg) {
    var body, err, header, json_encoding, obj, payload;
    header = _arg.header, body = _arg.body, json_encoding = _arg.json_encoding;
    obj = {
      body: body,
      header: header
    };
    err = null;
    payload = (function() {
      switch (json_encoding) {
        case K.json_encoding.plain:
          return JSON.stringify(obj);
        case K.json_encoding.msgpack:
          return pack(obj);
        default:
          return err = new Error("bad json_encoding scheme: " + json_encoding);
      }
    })();
    return [err, payload];
  };

  sign = function(_arg, cb) {
    var body, err, hasher, header, include_body, json_encoding, key, output, payload, progress_hook, sig, type, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, type = _arg.type, body = _arg.body, hasher = _arg.hasher, progress_hook = _arg.progress_hook, json_encoding = _arg.json_encoding, include_body = _arg.include_body;
    if (hasher == null) {
      hasher = SHA512;
    }
    if (json_encoding == null) {
      json_encoding = K.json_encoding.msgpack;
    }
    header = {
      type: type,
      version: K.versions.V1,
      hasher: hasher.type,
      padding: K.padding.EMSA_PCKS1_v1_5,
      json_encoding: json_encoding
    };
    _ref1 = json_encode({
      json_encoding: json_encoding,
      header: header,
      body: body
    }), err = _ref1[0], payload = _ref1[1];
    (function(_this) {
      return (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/keybase/sign.iced"
            });
            key.pad_and_sign(payload, {
              hasher: hasher
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return sig = arguments[0];
                };
              })(),
              lineno: 29
            }));
            __iced_deferrals._fulfill();
          })(function() {
            output = {
              header: header,
              sig: sig
            };
            return __iced_k(include_body ? output.body = body : void 0);
          });
        } else {
          return __iced_k();
        }
      });
    })(this)((function(_this) {
      return function() {
        return cb(err, output);
      };
    })(this));
  };

  verify = function(_arg, cb) {
    var body, err, hasher, hd, header, json_encoding, key, payload, progress_hook, sig, type, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    type = _arg.type, key = _arg.key, sig = _arg.sig, body = _arg.body, progress_hook = _arg.progress_hook;
    header = hd = sig.header;
    json_encoding = header.json_encoding;
    hasher = alloc(header.hasher);
    _ref1 = json_encode({
      json_encoding: json_encoding,
      header: header,
      body: body
    }), err = _ref1[0], payload = _ref1[1];
    err = err != null ? err : hd.version !== K.versions.V1 ? new Error("unknown version: " + header.version) : hd.padding !== K.padding.EMSA_PCKS1_v1_5 ? new Error("unknown padding: " + header.padding) : type !== hd.type ? new Error("Unexpected sig type; wanted " + type + ", got " + hd.type) : null;
    (function(_this) {
      return (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/keybase/sign.iced"
            });
            key.verify_unpad_and_check_hash({
              sig: sig.sig,
              data: payload,
              hasher: hasher
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 48
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      });
    })(this)((function(_this) {
      return function() {
        return cb(err);
      };
    })(this));
  };

  exports.sign = sign;

  exports.verify = verify;

  exports.json_encode = json_encode;

}).call(this);
